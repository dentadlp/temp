<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Architecture &mdash; Netmaker 0.24.3 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/custom.css" type="text/css" />
      <link rel="stylesheet" href="_static/fonts.css" type="text/css" />
      <link rel="stylesheet" href="_static/netmaker-custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Getting Started" href="getting-started.html" />
    <link rel="prev" title="About" href="about.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html">
            
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="about.html">About</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="about.html#what-is-netmaker">What is Netmaker?</a></li>
<li class="toctree-l2"><a class="reference internal" href="about.html#how-does-netmaker-work">How Does Netmaker Work?</a></li>
<li class="toctree-l2"><a class="reference internal" href="about.html#use-cases-for-netmaker">Use Cases for Netmaker</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="about.html#architecture">Architecture</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Architecture</a></li>
<li class="toctree-l3"><a class="reference internal" href="#core-concepts">Core Concepts</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#wireguard">WireGuard</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mesh-network">Mesh Network</a></li>
<li class="toctree-l4"><a class="reference internal" href="#netmaker">Netmaker</a></li>
<li class="toctree-l4"><a class="reference internal" href="#node">Node</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#components">Components</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#netmaker-server">Netmaker Server</a></li>
<li class="toctree-l4"><a class="reference internal" href="#message-broker-mosquitto">Message Broker (Mosquitto)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#netclient">Netclient</a></li>
<li class="toctree-l4"><a class="reference internal" href="#database-sqlite-rqlite-postgres">Database (SQLite, rqlite, postgres)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#netmaker-ui">Netmaker UI</a></li>
<li class="toctree-l4"><a class="reference internal" href="#coredns">CoreDNS</a></li>
<li class="toctree-l4"><a class="reference internal" href="#caddy">Caddy</a></li>
<li class="toctree-l4"><a class="reference internal" href="#remote-access-clients">Remote Access Clients</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#technical-process">Technical Process</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compatible-systems-for-netclient">Compatible Systems for Netclient</a></li>
<li class="toctree-l3"><a class="reference internal" href="#limitations">Limitations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="getting-started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="pro/index.html">Netmaker Professional</a></li>
<li class="toctree-l1"><a class="reference internal" href="upgrades.html">Upgrades</a></li>
<li class="toctree-l1"><a class="reference internal" href="how-to-guides.html">How-to-Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="references.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="conduct.html">Code of Conduct</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Netmaker</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="about.html">About</a></li>
      <li class="breadcrumb-item active">Architecture</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="architecture">
<h1>Architecture<a class="headerlink" href="#architecture" title="Permalink to this headline"></a></h1>
<a class="reference internal image-reference" href="_images/nm-diagram-3.png"><img alt="Netmaker Architecture Diagram" class="align-center" src="_images/nm-diagram-3.png" style="width: 100%;" /></a>
<p><em>Pictured Above: A detailed diagram of Netmaker’s Architecture.</em></p>
</section>
<section id="core-concepts">
<h1>Core Concepts<a class="headerlink" href="#core-concepts" title="Permalink to this headline"></a></h1>
<p>Familiarity with several core concepts will help when you encounter them later in the documentation.</p>
<section id="wireguard">
<h2>WireGuard<a class="headerlink" href="#wireguard" title="Permalink to this headline"></a></h2>
<p>WireGuard is a relatively new but very important technology that was recently added to the Linux kernel. WireGuard creates very fast but simple encrypted tunnels between devices. From the <a class="reference external" href="https://www.wireguard.com/">WireGuard</a> website, “it might be regarded as the most secure, easiest to use, and simplest VPN solution in the industry.”</p>
<p>Previous solutions like OpenVPN and IPSec are considerably more heavy and complex while being less performant. All existing VPN tunneling solutions will cause a significant increase in your network latency. WireGuard is the first to achieve near over-the-line network speeds, meaning you see no significant performance impact.  With the release of WireGuard, there is little reason to use any other existing tunnel encryption technology.</p>
</section>
<section id="mesh-network">
<h2>Mesh Network<a class="headerlink" href="#mesh-network" title="Permalink to this headline"></a></h2>
<p>When we refer to a mesh network in these documents we are typically referring to a “full mesh.”</p>
<a class="reference internal image-reference" href="_images/mesh.png"><img alt="Full Mesh Network Diagram" class="align-center" src="_images/mesh.png" style="width: 33%;" /></a>
<p>A full <a class="reference external" href="https://www.bbc.co.uk/bitesize/guides/zr3yb82/revision/2">mesh network</a> exists where each machine is able to directly talk to every other machine on the network. For example, on your home network, behind your router, all the computers are likely given private addresses and can reach each other directly.</p>
<p>This is in contrast to a hub-and-spoke network, where each machine must first pass its traffic through a relay server before it can reach other machines.</p>
<p>In certain situations, you may either want or need a <em>partial mesh</em> network, where only some devices can reach each other directly, and other devices must route their traffic through a relay/gateway. Netmaker can use this model in some use cases where it makes sense. In the diagram at the top of this page, the setup is a partial mesh because the servers (nodes A-D) are meshed, but then Remote Access Clients come in via a gateway and are not meshed.</p>
<p>Mesh networks are generally faster than other topologies but are also more complicated to set up. WireGuard on its own gives you the means to create encrypted tunnels between devices, but it does not provide a method for setting up a full network. This is where Netmaker comes in.</p>
</section>
<section id="netmaker">
<h2>Netmaker<a class="headerlink" href="#netmaker" title="Permalink to this headline"></a></h2>
<p>Netmaker is a platform built off of WireGuard enabling users to create mesh networks between their devices. Netmaker can create both full and partial mesh networks depending on the use case.</p>
<p>When we refer to Netmaker in aggregate, we are typically referring to Netmaker and the netclient, as well as other supporting services such as CoreDNS, SQLite,  Mosquitto (MQ Broker), and UI webserver. There is also almost always a proxy server / LB, which by default is Traefik, but could be any number of tools.</p>
<p>From an end user perspective, they typically interact with the Netmaker UI. The other components run in the background invisibly.</p>
<p>Netmaker does a lot of work to set configurations for you so that you don’t have to. This includes things like WireGuard ports, endpoints, public IPs, keys, and peers. Netmaker works to abstract away as much of the network management as possible, so that you can just click to create a network, and click to add a machine to a network. That said, every machine (node) is different, and may require special configuration. That is why, while Netmaker sets practical default settings, everything within Netmaker is fully configurable.</p>
</section>
<section id="node">
<h2>Node<a class="headerlink" href="#node" title="Permalink to this headline"></a></h2>
<p>A machine in a Netmaker network, which is managed by the Netclient, is referred to as a Node, as you will see in the UI. A Node can be a VM, a bare metal server, a desktop computer, an IoT device, or any other number of internet-connected machines on which the netclient is installed. A node is simply an endpoint in the network, which can send traffic to all the other nodes, and receive traffic from all of the other nodes.</p>
</section>
</section>
<section id="components">
<h1>Components<a class="headerlink" href="#components" title="Permalink to this headline"></a></h1>
<p>Netmaker consists of several core components, which are explained in high-level technical detail below.</p>
<section id="netmaker-server">
<h2>Netmaker Server<a class="headerlink" href="#netmaker-server" title="Permalink to this headline"></a></h2>
<p>The Netmaker server is, at its core, a golang binary. Source code can be found <a class="reference external" href="https://github.com/gravitl/netmaker">on GitHub</a>. The binary, by itself, can be compiled for most systems. If you need to run the Netmaker server on a particular system, it likely can be made to work. In typical deployments, it is run as a Docker container. It can also be run as a systemd service as outlined in the non-docker install guide.</p>
<p>The Netmaker server acts as an API to the front end and publishes messages to clients via an MQ broker. The Netmaker server also runs an embedded “netclient” for each network that is created. This is a special netclient that enabled “UDP Hole Punching” on the system. When nodes reach the server, Netmaker uses this netclient to determine a routable address for each machine, and sends this out to the network.</p>
<p>Most server settings are configurable via a config file, or by environment variables (which take precedence). If the server finds neither of these, it sets sensible defaults, including things like the server’s reachable IP, ports, and which “modes” to run in.</p>
<p>The Netmaker server interacts with either SQLite (default), postgres, or rqlite, a distributed version of SQLite, as its database. This DB holds information about nodes, networks, users, and other important data. This data is configuration data.</p>
<p>When the netmaker server needs to send an update to nodes, it publishes a message to the broker, MQ.</p>
<p>The components of the server are usually proxied via Traefik or an alternative like Nginx or Caddy. The proxy handles SSL certificates to secure traffic, and routes to the UI and API.</p>
</section>
<section id="message-broker-mosquitto">
<h2>Message Broker (Mosquitto)<a class="headerlink" href="#message-broker-mosquitto" title="Permalink to this headline"></a></h2>
<p>The Mosquitto broker is the default MQTT broker that ships with Netmaker, though technically, any MQTT broker should work so long as the correct configuration is applied. The broker enables the establishment of a pub-sub messaging system, whereby clients subscribe to receive updates. When the server receives a change, it will publish that change to the broker that pushes out the change to the appropriate nodes.</p>
<p>The broker must be reachable over a public address.</p>
</section>
<section id="netclient">
<h2>Netclient<a class="headerlink" href="#netclient" title="Permalink to this headline"></a></h2>
<p>The netclient is, at its core, a golang binary. Source code can be found in the Netclient <a class="reference external" href="https://www.github.com/gravitl/netclient">GitHub Repository</a>. The binary, by itself, can be compiled for most systems. However, this binary is designed to manage a certain number of Operating Systems.</p>
<p>The netclient can be installed in one of two way: using package manager for your os/DE or by downloading the binary for your operating system/architecture from the netclient github repository and running ./netclient install.</p>
<p>After installation netclient commands can be executed to ‘join’ or ‘register’ with the netmaker server.</p>
<p>The ‘join’ and ‘register’ command attempts to add the machine to the Netmaker network using sensible defaults, which can be overridden with a config file or environment variables. Assuming the netclient has a valid key (or the network allows manual node signup), it will be registered into the Netmaker network, and will be returned necessary configuration details for how to set up its local network.</p>
<p>The netclient automatically registers with the MQTT server running with Netmaker, which will send it periodic updates when the network changes.</p>
<p>The netclient then sets up the system daemon (if running in daemon mode), and configures WireGuard. At this point, it should be part of the network.</p>
<p>The netclient will detect local changes and send them to the server when necessary. A change to IP address or port will lead to a network update to keep everything in sync. If the node is not running with the in daemon on, it is up to the operator to keep the netclient up-to-date by running regular “pulls” (netclient pull).</p>
<p>The MQ pub-sub system allows Netmaker to create dynamic mesh networks. As nodes are added to, removed from, and modified on the network, other nodes are notified and make appropriate changes.</p>
</section>
<section id="database-sqlite-rqlite-postgres">
<h2>Database (SQLite, rqlite, postgres)<a class="headerlink" href="#database-sqlite-rqlite-postgres" title="Permalink to this headline"></a></h2>
<p>Netmaker uses embedded SQLite as the default database. It can also use PostgreSQL, or rqlite, a distributed (RAFT consensus) database. Netmaker interacts with the database to store and retrieve information about nodes, networks, and users.</p>
<p>Additional database support (besides SQLite and rqlite) is very easy to implement for special use cases. Netmaker uses simple key-value lookups to run the networks, and the database was designed to be extensible, so support for key-value stores and other SQL-based databases can be achieved by changing a single file.</p>
</section>
<section id="netmaker-ui">
<h2>Netmaker UI<a class="headerlink" href="#netmaker-ui" title="Permalink to this headline"></a></h2>
<p>The Netmaker UI is a ReactJS-based static website which can be run on top of standard webservers such as Apache and Nginx. Source code can be found <a class="reference external" href="https://github.com/gravitl/netmaker-ui-2">here</a>. In a typical configuration, the Netmaker UI is run on Nginx as a Docker container.</p>
<p>Netmaker can be used in its entirety without the UI, but the UI makes things a lot easier for most users. It has a sensible flow and layout for managing Networks, Nodes, Access Keys, and DNS.</p>
</section>
<section id="coredns">
<h2>CoreDNS<a class="headerlink" href="#coredns" title="Permalink to this headline"></a></h2>
<p>As of 0.22.0, CoreDNS is an active part of the Netmaker system. We deprecated setting entries on the hosts file which was not an ideal implementation.
Netmaker server actively sets the dns entries on the CoreDNS server.
After you install the netmaker server components, you can see the corendns container running as well.
You need to make some changes manually to activate the corendns server, follow these steps on the netmaker server:</p>
<ol class="arabic simple">
<li><p>Make sure that UDP Port 53 and TCP Port 53 are allowed to pass in the network where your netmaker server lies</p></li>
<li><p>disable the systemd-resolved (Reason: to avoid port conflict with coredns server)</p></li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sudo</span> <span class="n">systemctl</span> <span class="n">disable</span> <span class="n">systemd</span><span class="o">-</span><span class="n">resolved</span><span class="o">.</span><span class="n">service</span>
<span class="n">sudo</span> <span class="n">systemctl</span> <span class="n">stop</span> <span class="n">systemd</span><span class="o">-</span><span class="n">resolved</span>
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li><p>Make sure the <cite>network_mode: host</cite> is set on the coredns container spec in <cite>/root/docker-compose.yml</cite> and run <cite>docker-compose up -d</cite></p></li>
</ol>
<p>And now you can point any machine in the network to use this DNS server and you can reach the other peers in the network by their domain names.</p>
<p>For external clients running linux, make sure ‘resolvconf’ is installed before setting the Wireguard configurations.</p>
<p>Refer to your operating system documentation for information about how to configure custom DNS network settings. Here are some general help guides on how to add custom DNS server:</p>
<ol class="arabic simple">
<li><p>Linux - <a class="reference external" href="https://devilbox.readthedocs.io/en/latest/howto/dns/add-custom-dns-server-on-linux.html">https://devilbox.readthedocs.io/en/latest/howto/dns/add-custom-dns-server-on-linux.html</a>. Configuration depends on what distribution of Linux you use.</p></li>
<li><p>Mac - <a class="reference external" href="https://devilbox.readthedocs.io/en/latest/howto/dns/add-custom-dns-server-on-mac.html">https://devilbox.readthedocs.io/en/latest/howto/dns/add-custom-dns-server-on-mac.html</a></p></li>
<li><p>Windows - <a class="reference external" href="https://devilbox.readthedocs.io/en/latest/howto/dns/add-custom-dns-server-on-win.html">https://devilbox.readthedocs.io/en/latest/howto/dns/add-custom-dns-server-on-win.html</a></p></li>
</ol>
<p>If your machine is virtually hosted in a cloud, you might want to refer to your VM provider’s documention on how to permanently set the custom DNS resolver.</p>
</section>
<section id="caddy">
<h2>Caddy<a class="headerlink" href="#caddy" title="Permalink to this headline"></a></h2>
<p>As of 0.17.0, Caddy is the default proxy for Netmaker if you set it up via Quick Start. Caddy is a simple and docker-friendly proxy, which can be compared to Nginx, Traefik, or HAProxy.</p>
<p>Caddy simplifies management because the configuration file is very short, several lines compared to dozens of lines for Traefik or Nginx. In addition, it can request certificates automatically.</p>
<p>Traefik was previously the default and is still a functioning option, but We are moving guidance towards Caddy by default. If you are maintaining an installation that relies on Traefik, you can continue to use it with Netmaker.</p>
</section>
<section id="remote-access-clients">
<h2>Remote Access Clients<a class="headerlink" href="#remote-access-clients" title="Permalink to this headline"></a></h2>
<p>The Remote Access Clients (client external to the mesh network) is simply a configured WireGuard connection to your network, which Netmaker helps to manage.</p>
<p>Most machines can run WireGuard. Setting up a WireGuard connection to a single endpoint is fairly simple. It is setting up mesh networks and other topologies like site-to-site which becomes complicated.</p>
<p>Mac, Windows, and Linux are handled natively by the Netclient, though you can still add them as ext clients if you wish. Primarily, iPhone and Android are the main systems unsupported by the Netclient which MUST be handled via Remote Access Client.</p>
<p>Remote Access Clients hook into a Netmaker network via an “Remote Access Gateway (ingress),” which is configured for a given node and allows traffic to flow into the network. Remote Access Clients are also reachable via the gateway. While this is a “concentrator” and not peer-to-peer, this is often desirable.</p>
<p>Many users use Remote Access Clients clients as a convenient way to manage remote access for their users. Why? It works with vanilla WireGuard for one. You simply download the config and load it into WireGuard on the client device. No additional software is required. It can also be quite helpful to have a “choke point” for traffic (the gateway) rather than direct p2p connections to every machine.</p>
</section>
</section>
<section id="technical-process">
<h1>Technical Process<a class="headerlink" href="#technical-process" title="Permalink to this headline"></a></h1>
<p>Below is a high level, step-by-step overview of the flow of communications within Netmaker (assuming Netmaker has already been installed):</p>
<ol class="arabic simple">
<li><p>Admin creates a new network with a subnet, for instance, 10.10.10.0/24</p></li>
<li><p>Admin creates a registration key for signing up new nodes</p></li>
<li><p>Both of the above requests are routed to the server via an API call from the front end</p></li>
<li><p>Admin installs the netclient binary on any given node (machine) and runs netclient join or register command.</p></li>
<li><p>Netclient decodes key, which contains the server location</p></li>
<li><p>Netclient gathers and sets appropriate information to configure itself as a node: it generates key pairs, gets public and local addresses, and sets a port.</p></li>
<li><p>Netclient sends this information to the server, authenticating with its registration key</p></li>
<li><p>Netmaker server verifies information and creates the node, setting default values for any missing information, and returns a response.</p></li>
<li><p>Netmaker also registers the client with MQ.</p></li>
<li><p>Upon successful registration, Netclient pulls the latest peers list from the server and set up a WireGuard interface.</p></li>
<li><p>Netclient subscribes to the MQ broker.</p></li>
<li><p>Netclient configures itself as a daemon (if joining for the first time).</p></li>
<li><p>Netclient regularly retrieves local information, checking for changes in things like IP and keys. If there is a change, it pushes them to the server.</p></li>
<li><p>If a change occurs in any other peer or peers are added/removed, an update will be sent to the Netclient via MQ, and it will re-configure WireGuard.</p></li>
</ol>
</section>
<section id="compatible-systems-for-netclient">
<h1>Compatible Systems for Netclient<a class="headerlink" href="#compatible-systems-for-netclient" title="Permalink to this headline"></a></h1>
<p>To manage a node manually, the netclient can be compiled and run for most Linux distibutions, with a prerequisite of WireGuard with kernel headers. If the netclient from the release pages does not run natively on your system, you may need to compile the netclient binary directly on the machine from the source code. This may be true for some installations of SUSE, Fedora, and some Debian-based systems. However, if the dependencies are installed on the machine, the netclient should run correctly after being compiled.</p>
<p>Simply clone the repo, cd to netmaker/netclient, and run “go build” (Golang must be installed).</p>
<dl class="simple">
<dt>The following systems should be operable natively with Netclient in daemon mode:</dt><dd><ul class="simple">
<li><p>Windows</p></li>
<li><p>Mac</p></li>
<li><p>FreeBSD</p></li>
<li><p>OpenWRT</p></li>
<li><p>Fedora</p></li>
<li><p>Ubuntu</p></li>
<li><p>Debian</p></li>
<li><p>Mint</p></li>
<li><p>SUSE</p></li>
<li><p>RHEL</p></li>
<li><p>Raspian</p></li>
<li><p>Arch</p></li>
<li><p>CentOS</p></li>
<li><p>Fedora CoreOS</p></li>
</ul>
</dd>
</dl>
<p>Systemd is a system service manager for a wide array of Linux operating systems, but not all Linux distributions have adopted systemd. If you need to run on a Linux distro without systemd, we recommend the following: Join “unmanaged” with <strong>netclient join -daemon=off</strong> on Linux systems that do not run systemd and use some other method to run the daemon like a cron job or custom script.</p>
</section>
<section id="limitations">
<h1>Limitations<a class="headerlink" href="#limitations" title="Permalink to this headline"></a></h1>
<p>Install limitations mostly include platform-specific dependencies. A failed netclient install should display information about which command is failing, or which libraries are missing. This can often be solved via machine upgrade, installing missing dependencies, or setting kernel headers on the machine for WireGuard (e.x.: <a class="reference external" href="https://stackoverflow.com/questions/62356581/wireguard-vpn-how-to-fix-operation-not-supported-if-it-worked-before">Installing Kernel Headers on Debian</a>)</p>
<p>It is very helpful if an install fails to run “netclient join -t &lt;token&gt; -v 4”. By default, the install runs with minimal logging. The -v flags will display any encountered errors. You can set the verbosity fron 0-4.</p>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="about.html" class="btn btn-neutral float-left" title="About" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="getting-started.html" class="btn btn-neutral float-right" title="Getting Started" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Netmaker Inc..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>